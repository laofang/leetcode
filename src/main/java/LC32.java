/**
 * Leetcode32题,最长有效括号
 * 关键字；动态数组
 * 主要思路：
 * 1. 动态数组dp[i]表示以s[i]为结尾的字符串，有效括号长度是多长
 * 2. 如果s[i]='('，则以s[i]为结尾的字符串，有效括号长度为0
 * 3. 如果s[i]=')'，则分为两种情况讨论：
 *      1. 如果s[i-1] = '('：
 *          说明s[i]和s[i-1]是一对，所以当前有效括号长度，就是s[i-2]结尾的有效长度+s[i]和s[i-1]这一对，也就是
 *          dp[i] = dp[i-2] + 2;
 *      2. 如果s[i-1] = ')'：
 *          我们首先找一下s[i]的对应括号'('的位置。对应括号'('的位置，应当是以s[i-1]结尾的最长有效括号长度之前的那一个字符
 *          也就是i - dp[i-1] - 1;
 *          如果s[i] != s[i-dp[i-1] -1]，dp[i]=0
 *          如果s[i] == s[i-dp[i-1] -1]，dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]
 *              dp[i-1]+2这部分是相对dp[i-1]增长的长度，但i - dp[i-1] - 1的位置都匹配了，这就要再看一下前面，可以把前面联系起来
 *              这就是dp[i - dp[i-1] -2];
 * 注意的地方：
 *      1. dp[i-2]，dp[i - dp[i-1] - 1]，dp[i - dp[i-1] - 2]小于0的情况
 *          1. dp[i-2] < 0的情况，i = 1的时候，s[0]和s[1]匹配，但没有更前的字符串，如"()";
 *          2. dp[i - dp[i-1] - 1 < 0， 最后的')'没有之前的匹配，如"(()))";
 *          3. dp[i - dp[i-2] - 2 < 0,  最后一个')'的匹配'('的下标是0，如"((()))";
 */
public class LC32 {
    public int longestValidParentheses(String s) {
        //最大长度
        int maxLen = 0;
        if(s.length() == 0 || s.length() == 1) {
            return maxLen;
        }
        //动态数组赋初值dp[i]代表到下标i的位置，最大有效括号的长度
        int[] dp = new int[s.length()];
        for (int i : dp) {
            i = 0;
        }
        //从第一个位置遍历每一个字符
        for(int i = 1; i < s.length();i++) {
            char cur = s.charAt(i);
            //字符是'('，有效字符长度肯定是0，只有是')'才进行进一步判断
            if(s.charAt(i) == ')') {
                //如果和前一个匹配，则dp[i] = dp[i-2] + 2;
                if (s.charAt(i - 1) == '(') {
                    //如果不存在i-2 当i==1时
                    dp[i] = i == 1? 2 : dp[i-2] + 2;
                    //如果i和i-1都是')'，则可以找到对应位置是否有'('
                } else if (s.charAt(i - 1) == ')') {
                    //没有对应位置
                    if(i - dp[i-1] - 1 < 0) {
                        dp[i] = 0;
                    }
                    //有对应位置
                    else if (s.charAt(i - dp[i - 1] - 1) == '(') {
                        //有对应位置，但对应位置的索引是0没有再之前的元素了
                        dp[i] = i - dp[i-1] - 2 < 0 ?
                                dp[i-1] + 2 :
                                dp[i-1] + 2 + dp[i-dp[i-1] - 2];
                    }
                }
                //更新最长长度
                if (dp[i] > maxLen) {
                    maxLen = dp[i];
                }
            }
        }
        return maxLen;
    }

    //TODO ”最长有效括号“ 栈解法

    //TODO ”最长有效括号“ 左右计数器解法
}